"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  uniformCLI: () => uniformCLI
});
module.exports = __toCommonJS(src_exports);

// src/commands/new.ts
var import_inquirer4 = __toESM(require("inquirer"));

// src/actions/chooseTeam.ts
var import_inquirer = __toESM(require("inquirer"));
async function chooseTeam(user, prompt, telemetry) {
  const result = await import_inquirer.default.prompt([
    {
      type: "list",
      name: "teamId",
      message: prompt,
      choices: user.teams.map((team) => ({
        name: team.team.name,
        value: team.team.id
      }))
    }
  ]);
  telemetry.send("team picked", { teamId: result.teamId });
  return result;
}

// src/actions/cloneStarter.ts
var import_degit = __toESM(require("degit"));
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));

// src/npm.ts
var import_execa = __toESM(require("execa"));
var runNpm = async (workDir, args, { inherit, env } = {}) => {
  let result;
  try {
    result = await (0, import_execa.default)("npm", args, {
      cwd: workDir,
      env: env != null ? env : {},
      ...inherit ? { stdout: "inherit", stderr: "inherit" } : {}
    });
  } catch (err) {
    throw new Error(`Failed to execute npm ${args.join(" ")}
${err.message}`);
  }
  if (result.exitCode !== 0) {
    throw new Error(`Command npm ${args.join(" ")} exitted with code ${result == null ? void 0 : result.exitCode}}: ${result.stderr}`);
  }
  return result.stdout;
};

// src/actions/cloneStarter.ts
async function cloneStarter({
  spin,
  githubPath,
  targetDir,
  dotEnvFile
}) {
  const done = await spin("Fetching starter code...");
  try {
    await (0, import_degit.default)(githubPath).clone(targetDir);
  } catch (err) {
    throw new Error(`Failed to fetch starter code: ${err.message}`);
  }
  await done();
  if (dotEnvFile) {
    import_fs.default.writeFileSync(import_path.default.resolve(targetDir, ".env"), dotEnvFile, "utf-8");
  }
  console.log(`
Your project now lives in ${targetDir} \u2728`);
  return {
    runNpmInstall: async () => {
      console.log(`
Installing project dependencies...

`);
      await runNpm(targetDir, ["i"], { inherit: true });
    }
  };
}

// src/client.ts
var import_zod = require("zod");

// src/api-key.ts
var READ_PERMISSIONS = ["PROJECT", "UPM_PUB", "OPT_PUB", "OPT_READ", "UPM_READ"];
var WRITE_PERMISSIONS = [
  "PROJECT",
  "UPM_SCHEMA",
  "UPM_READ",
  "UPM_PUB",
  "UPM_CREATE",
  "UPM_WRITE",
  "UPM_DELETE",
  "UPM_PUBLISH",
  "OPT_READ",
  "OPT_CREATE_ENRICHMENTS",
  "OPT_WRITE_ENRICHMENTS",
  "OPT_DELETE_ENRICHMENTS",
  "OPT_CREATE_INTENTS",
  "OPT_WRITE_INTENTS",
  "OPT_DELETE_INTENTS",
  "OPT_PUB",
  "OPT_PUBLISH",
  "OPT_CREATE_QUIRKS",
  "OPT_WRITE_QUIRKS",
  "OPT_DELETE_QUIRKS",
  "OPT_CREATE_SIGNALS",
  "OPT_WRITE_SIGNALS",
  "OPT_DELETE_SIGNALS",
  "OPT_CREATE_TESTS",
  "OPT_WRITE_TESTS",
  "OPT_DELETE_TESTS"
];
var makeApiKey = (teamId, projectId, name, permissions) => ({
  name,
  teamId,
  projects: [
    {
      projectId,
      permissions,
      roles: [],
      useCustom: true
    }
  ],
  email: "",
  identity_subject: "",
  isAdmin: false
});
var makeReadApiKey = (teamId, projectId) => makeApiKey(teamId, projectId, "Created by Uniform New (read)", READ_PERMISSIONS);
var makeWriteApiKey = (teamId, projectId) => makeApiKey(teamId, projectId, "Created by Uniform New (write)", WRITE_PERMISSIONS);

// src/url.ts
var makeUrl = (baseUrl, path4) => [baseUrl.trim().replace(/\/+$/, ""), path4.trim().replace(/^\/+/, "")].join("/");

// src/client.ts
var createTeamOrProjectSchema = import_zod.z.object({ id: import_zod.z.string().min(1) });
var createApiKeySchema = import_zod.z.object({ apiKey: import_zod.z.string().min(1) });
var getLimitsSchema = import_zod.z.object({
  limits: import_zod.z.object({
    projects: import_zod.z.array(
      import_zod.z.object({ id: import_zod.z.string().min(1), name: import_zod.z.string().min(1), used: import_zod.z.number(), limit: import_zod.z.number() })
    )
  })
});
var createClient = (baseUrl, authToken) => {
  const request2 = async (path4, opts) => {
    const res = await fetch(makeUrl(baseUrl, path4), {
      ...opts,
      headers: { Authorization: `Bearer ${authToken}` }
    });
    if (res.ok) {
      return res;
    } else {
      throw new Error(
        `Non-2xx API response: ${opts.method} ${path4} responded with ${res.status} ${res.statusText}`
      );
    }
  };
  const requestJson = async (path4, opts, schema2) => {
    const res = await request2(path4, opts);
    const data = await res.json();
    const parseResult = schema2.safeParse(data);
    if (parseResult.success) {
      return parseResult.data;
    } else {
      throw new Error(`Invalid ${opts.method} ${path4} response: ${parseResult.error.message}`);
    }
  };
  return {
    createTeam: async (name) => {
      try {
        const result = await requestJson(
          "/api/v1/team",
          { method: "POST", body: JSON.stringify({ name }) },
          createTeamOrProjectSchema
        );
        return result.id;
      } catch (err) {
        throw new Error(`Failed to create team:
  ${err.message}`);
      }
    },
    createProject: async (teamId, name, previewUrl) => {
      try {
        const { limits } = await requestJson(
          `/api/v1/limits?teamId=${teamId}`,
          { method: "POST" },
          getLimitsSchema
        );
        const projectTypeBelowLimit = limits.projects.find((project) => project.used < project.limit);
        if (!projectTypeBelowLimit) {
          throw new Error("Usage exceeded.");
        }
        const result = await requestJson(
          "/api/v1/project",
          {
            method: "POST",
            body: JSON.stringify({
              organization_id: teamId,
              name,
              site_type_id: projectTypeBelowLimit.id,
              ui_version: 3,
              preview_url: previewUrl
            })
          },
          createTeamOrProjectSchema
        );
        return result.id;
      } catch (err) {
        throw new Error(`Failed to create project:
  ${err.message}`);
      }
    },
    createApiKeys: async (teamId, projectId) => {
      try {
        const { apiKey: readApiKey } = await requestJson(
          "/api/v1/members",
          {
            method: "PUT",
            body: JSON.stringify(makeReadApiKey(teamId, projectId))
          },
          createApiKeySchema
        );
        const { apiKey: writeApiKey } = await requestJson(
          "/api/v1/members",
          {
            method: "PUT",
            body: JSON.stringify(makeWriteApiKey(teamId, projectId))
          },
          createApiKeySchema
        );
        return { readApiKey, writeApiKey };
      } catch (err) {
        throw new Error(`Failed to create API key:
  ${err.message}`);
      }
    },
    installCanvas: async (projectId) => {
      try {
        await request2(`/api/v1/integrations?integration=canvas&action=install&site=${projectId}`, {
          method: "POST"
        });
      } catch (err) {
        throw new Error(`Failed to install Canvas:
  ${err.message}`);
      }
    },
    registerMeshIntegration: async ({ teamId, manifest }) => {
      try {
        const { type } = await requestJson(
          "/api/v1/integration-definitions",
          {
            method: "PUT",
            body: JSON.stringify({ teamId, data: manifest })
          },
          import_zod.z.object({ type: import_zod.z.string() })
        );
        return type;
      } catch (err) {
        throw new Error(`Failed to register integration:
  ${err.message}`);
      }
    },
    installIntegration: async ({ projectId, type }) => {
      try {
        await request2("/api/v1/integration-installations", {
          method: "PUT",
          body: JSON.stringify({ projectId, type })
        });
      } catch (err) {
        throw new Error(`Failed to install integration to project:
  ${err.message}`);
      }
    }
  };
};

// src/user-info.ts
var import_graphql_request = require("graphql-request");
var import_zod2 = require("zod");
var query = import_graphql_request.gql`
  query GetUserInfo($subject: String!) {
    info: identities_by_pk(subject: $subject) {
      name
      email_address
      teams: organizations_identities {
        team: organization {
          name
          id
          sites {
            name
            id
          }
        }
      }
    }
  }
`;
var schema = import_zod2.z.object({
  info: import_zod2.z.object({
    name: import_zod2.z.string().min(1),
    email_address: import_zod2.z.string().min(1),
    teams: import_zod2.z.array(
      import_zod2.z.object({
        team: import_zod2.z.object({
          name: import_zod2.z.string().min(1),
          id: import_zod2.z.string().min(1),
          sites: import_zod2.z.array(
            import_zod2.z.object({
              name: import_zod2.z.string().min(1),
              id: import_zod2.z.string().min(1)
            })
          )
        })
      })
    )
  })
});
var getUserInfo = async (baseUrl, authToken, subject) => {
  try {
    const endpoint = makeUrl(baseUrl, "/v1/graphql");
    const res = await (0, import_graphql_request.request)(endpoint, query, { subject }, { Authorization: `Bearer ${authToken}` });
    const parseResult = schema.safeParse(res);
    if (parseResult.success) {
      return parseResult.data.info;
    } else {
      throw new Error(`Invalid GraphQL response: ${parseResult.error.message}`);
    }
  } catch (err) {
    throw new Error(`Failed to fetch user account:
  ${err.message}`);
  }
};

// src/actions/fetchUserAndEnsureTeamExists.ts
async function fetchUserAndEnsureFirstTeamExists({
  baseUrl,
  auth: { authToken, decoded },
  spin,
  telemetry
}) {
  const uniformClient = createClient(baseUrl, authToken);
  const done = await spin("Fetching user information...");
  let user = await getUserInfo(baseUrl, authToken, decoded.sub);
  if (user.teams.length < 1) {
    await uniformClient.createTeam(`${user.name}'s team`);
    user = await getUserInfo(baseUrl, authToken, decoded.sub);
  }
  await done();
  telemetry.login(decoded.sub, user);
  return user;
}

// src/actions/getBearerToken.ts
var import_inquirer2 = __toESM(require("inquirer"));
var import_jsonwebtoken = __toESM(require("jsonwebtoken"));
var import_open = __toESM(require("open"));
async function getBearerToken(baseUrl) {
  const { canOpen } = await import_inquirer2.default.prompt([
    {
      type: "confirm",
      name: "canOpen",
      message: "Can we open a browser window to get a Uniform auth token?"
    }
  ]);
  if (canOpen) {
    (0, import_open.default)(makeUrl(baseUrl, "/cli-login"));
  }
  const tokenAnswer = await import_inquirer2.default.prompt([
    {
      type: "password",
      name: "authToken",
      message: "Paste your Uniform auth token"
    }
  ]);
  const authToken = tokenAnswer.authToken.trim();
  if (!authToken) {
    throw new Error("No auth token provided.");
  }
  const decoded = import_jsonwebtoken.default.decode(authToken, { complete: false });
  if (!decoded) {
    throw new Error("Could not parse the token pasted.");
  }
  if (typeof decoded.sub !== "string" || typeof decoded === "string") {
    throw new Error("Invalid token pasted.");
  }
  return {
    authToken,
    decoded: { ...decoded, sub: decoded.sub }
  };
}

// src/actions/getOrCreateProject.ts
var import_fs2 = __toESM(require("fs"));
var import_inquirer3 = __toESM(require("inquirer"));
var import_path2 = __toESM(require("path"));
var import_slugify = __toESM(require("slugify"));
var newProjectId = "$new";
async function getOrCreateProject({
  chooseExisting,
  createNew,
  teamId,
  user,
  explicitName,
  client,
  spin,
  checkTargetDir,
  explicitTargetDir,
  previewUrl,
  telemetry
}) {
  if (explicitName && !createNew) {
    throw new Error("Tried to specify explicit new project name when adding new project is not enabled.");
  }
  if (!createNew && !chooseExisting) {
    throw new Error("Must allow adding new, creating existing, or both.");
  }
  if (chooseExisting) {
    const { projectId, projectName } = await chooseExistingProject({ createNew, teamId, user });
    if (projectId !== newProjectId && projectName) {
      const targetDir = validateProjectName(projectName, checkTargetDir, explicitTargetDir);
      telemetry.send("project picked", { projectId, targetDir });
      return {
        projectId,
        projectName,
        targetDir
      };
    }
  }
  if (createNew) {
    const { projectName, targetDir } = await getNewProjectName({
      explicitName,
      checkTargetDir,
      explicitTargetDir
    });
    const projectId = await createProject({ client, projectName, spin, teamId, previewUrl });
    telemetry.send("project created", { projectId, targetDir });
    return {
      projectId,
      projectName,
      targetDir
    };
  }
  throw new Error("Insanity!");
}
async function getNewProjectName({
  explicitName,
  checkTargetDir,
  explicitTargetDir
}) {
  let projectName = explicitName;
  if (!projectName) {
    const answer = await import_inquirer3.default.prompt([
      {
        type: "input",
        name: "name",
        message: "What's your project name?",
        validate(input) {
          try {
            validateProjectName(input, checkTargetDir, explicitTargetDir);
            return true;
          } catch (e) {
            return e.message;
          }
        }
      }
    ]);
    projectName = answer.name;
  }
  projectName = projectName.trim();
  const targetDir = validateProjectName(projectName, checkTargetDir, explicitTargetDir);
  return { projectName, targetDir };
}
async function createProject({
  projectName,
  teamId,
  spin,
  client,
  previewUrl
}) {
  const done = await spin("Creating your new project...");
  const projectId = await client.createProject(teamId, projectName, previewUrl);
  await done();
  return projectId;
}
async function chooseExistingProject({
  createNew,
  teamId,
  user
}) {
  var _a, _b, _c;
  const projects = ((_b = (_a = user.teams.find((t) => t.team.id === teamId)) == null ? void 0 : _a.team.sites) != null ? _b : []).map((t) => ({
    name: t.name,
    value: t.id
  }));
  const choices = createNew ? [{ name: "Create new project...", value: newProjectId }].concat(projects) : projects;
  const result = await import_inquirer3.default.prompt([
    {
      type: "list",
      name: "projectId",
      message: "Choose a project",
      choices
    }
  ]);
  return {
    projectId: result.projectId,
    projectName: (_c = projects.find((p) => p.value === result.projectId)) == null ? void 0 : _c.name
  };
}
function validateProjectName(projectName, checkTargetDir, explicitTargetDir) {
  projectName = projectName.trim();
  const projectNameSlug = (0, import_slugify.default)(projectName);
  if (projectName.length < 3 || projectNameSlug.length < 3) {
    throw new Error("Project name cannot be shorter than 3 characters.");
  }
  if (checkTargetDir) {
    let targetDir = explicitTargetDir != null ? explicitTargetDir : process.cwd();
    if (!(0, import_fs2.existsSync)(targetDir)) {
      (0, import_fs2.mkdirSync)(targetDir, { recursive: true });
    }
    if (import_fs2.default.readdirSync(targetDir).length > 0) {
      targetDir = import_path2.default.resolve(targetDir, projectNameSlug);
      if (import_fs2.default.existsSync(targetDir)) {
        throw new Error(`${targetDir} already exists, choose a different name.`);
      }
    }
    return targetDir;
  }
}

// src/commands/new.ts
async function newHandler({
  spin,
  projectName,
  apiHost,
  outputPath,
  telemetry
}) {
  console.info(
    `Welcome to Uniform New! Let's create ${projectName ? `"${projectName}"` : "a new project"}... \u2764\uFE0F`
  );
  const auth = await getBearerToken(apiHost);
  const { authToken } = auth;
  const uniformClient = createClient(apiHost, authToken);
  const user = await fetchUserAndEnsureFirstTeamExists({ auth, baseUrl: apiHost, spin, telemetry });
  const { teamId } = await chooseTeam(
    user,
    `Hey ${user.name}! Choose a Uniform team for your new project`,
    telemetry
  );
  const {
    starter: { githubUri, serverUrl, previewPath, installEnv }
  } = await import_inquirer4.default.prompt([
    {
      type: "list",
      name: "starter",
      message: "Choose your preferred framework",
      choices: [
        {
          name: "Next.js",
          value: {
            githubUri: "uniformdev/examples/examples/nextjs-starter",
            serverUrl: "http://localhost:3000",
            previewPath: "/api/preview?secret=hello-world",
            installEnv: []
          }
        },
        {
          name: "Nuxt.js",
          value: {
            githubUri: "uniformdev/examples/examples/nuxtjs-starter",
            serverUrl: "http://localhost:3000",
            previewPath: "/?preview=true",
            installEnv: [["NUXT_TELEMETRY_DISABLED", "1"]]
          }
        }
      ]
    }
  ]);
  telemetry.send("starter picked", { githubUri });
  const { projectId, targetDir } = await getOrCreateProject({
    client: uniformClient,
    createNew: true,
    chooseExisting: false,
    spin,
    teamId,
    user,
    explicitName: projectName,
    targetDir: outputPath,
    checkTargetDir: true,
    previewUrl: serverUrl + previewPath,
    telemetry
  });
  let done = await spin("Generating API keys...");
  const { readApiKey, writeApiKey } = await uniformClient.createApiKeys(teamId, projectId);
  await done();
  const dotEnvFile = [
    ["UNIFORM_PROJECT_ID", projectId],
    ["UNIFORM_API_KEY", readApiKey],
    ["UNIFORM_CLI_API_KEY", writeApiKey],
    ...installEnv
  ].concat(
    apiHost !== "https://uniform.app" ? [
      ["UNIFORM_CLI_BASE_URL", apiHost],
      ["UNIFORM_API_HOST", apiHost]
    ] : []
  ).map(([name, value]) => `${name}='${value}'`).join("\n") + "\n";
  done = await spin("Installing Canvas...");
  await uniformClient.installCanvas(projectId);
  await done();
  const cloneStartTimestamp = Date.now();
  const { runNpmInstall } = await cloneStarter({
    githubPath: githubUri,
    spin,
    targetDir,
    dotEnvFile
  });
  telemetry.send("starter cloned", { duration: Date.now() - cloneStartTimestamp });
  const installStartTimestamp = Date.now();
  await runNpmInstall();
  telemetry.send("deps installed", { duration: Date.now() - installStartTimestamp });
  done = await spin("Creating components and compositions");
  await runNpm(targetDir, ["run", "uniform:push"]);
  await runNpm(targetDir, ["run", "uniform:publish"]);
  await done();
  telemetry.send("flow finished");
  console.log(`
  See your Uniform project and edit compositions by visiting:
  ${makeUrl(apiHost, `/projects/${projectId}`)}

`);
  if (process.platform.startsWith("win")) {
    console.log(`
Start your app server by executing:
  cd ${targetDir}
  npm run dev
`);
  } else {
    console.log(`
Hit Ctrl+C to exit; to run the server again execute:
cd ${targetDir}
npm run dev
`);
    console.log(`Your app is running at ${serverUrl} \u{1F389}
`);
    telemetry.send("server started");
    await runNpm(targetDir, ["run", "dev"]);
  }
}

// src/commands/new-mesh-integration.ts
var import_fs3 = require("fs");
var import_inquirer5 = __toESM(require("inquirer"));
var import_path3 = __toESM(require("path"));
var import_slugify2 = __toESM(require("slugify"));
async function newMeshIntegrationHandler({
  spin,
  apiHost,
  outputPath,
  telemetry
}) {
  console.info(`Welcome to Uniform New Integration! Let's create a new Uniform integration... \u2764\uFE0F`);
  const auth = await getBearerToken(apiHost);
  const { authToken } = auth;
  const uniformClient = createClient(apiHost, authToken);
  const user = await fetchUserAndEnsureFirstTeamExists({ auth, baseUrl: apiHost, spin, telemetry });
  const { teamId } = await chooseTeam(
    user,
    `Hey ${user.name}! Choose a Uniform team to register your integration`,
    telemetry
  );
  const answer = await import_inquirer5.default.prompt([
    {
      type: "input",
      name: "name",
      message: "Please name your integration",
      validate(input) {
        try {
          validateIntegrationName(input, outputPath);
          return true;
        } catch (e) {
          return e.message;
        }
      }
    }
  ]);
  const name = answer.name;
  const { targetDir, typeSlug } = validateIntegrationName(answer.name, outputPath);
  const { runNpmInstall } = await cloneStarter({
    githubPath: `uniformdev/examples/examples/mesh-integration`,
    spin,
    targetDir
  });
  let done = await spin("Registering integration to team...");
  const pathToManifest = import_path3.default.resolve(targetDir, "mesh-manifest.json");
  if (!(0, import_fs3.existsSync)(pathToManifest)) {
    throw new Error("Invalid integration starter cloned: missing `mesh-manifest.json`");
  }
  const manifestContents = (0, import_fs3.readFileSync)(pathToManifest, "utf-8");
  const manifestJson = JSON.parse(manifestContents);
  manifestJson.type = typeSlug;
  manifestJson.displayName = name;
  (0, import_fs3.writeFileSync)(pathToManifest, JSON.stringify(manifestJson, null, 2), "utf-8");
  const packageJsonPath = import_path3.default.resolve(targetDir, "package.json");
  const packageJson = JSON.parse((0, import_fs3.readFileSync)(packageJsonPath, "utf-8"));
  packageJson.name = typeSlug;
  (0, import_fs3.writeFileSync)(packageJsonPath, JSON.stringify(packageJson, null, 2), "utf-8");
  const fullMeshAppKey = await uniformClient.registerMeshIntegration({ teamId, manifest: manifestJson });
  await done();
  await runNpmInstall();
  console.log("\n\nChoose or create a project to install your integration to");
  const { projectId } = await getOrCreateProject({
    client: uniformClient,
    createNew: true,
    chooseExisting: true,
    spin,
    teamId,
    user,
    checkTargetDir: false,
    telemetry
  });
  done = await spin("Installing integration to project...");
  await uniformClient.installIntegration({ projectId, type: typeSlug });
  await done();
  console.log(`
Hit Ctrl/Cmd+C to exit; to run the mesh integration application again, execute:

  cd ${targetDir}
  npm run dev

See your integration registration by visiting:

  ${makeUrl(apiHost, `/teams/${teamId}/settings/custom-integrations`)}

See your integration's settings location by visiting:

  ${makeUrl(apiHost, `/projects/${projectId}/integrations/${fullMeshAppKey}`)}

`);
  console.log("Your integration is running at http://localhost:9000 \u{1F389}\n");
  await runNpm(targetDir, ["run", "dev"], { inherit: true });
}
function validateIntegrationName(integrationName, explicitOutputPath) {
  integrationName = integrationName.trim();
  const typeSlug = (0, import_slugify2.default)(integrationName, { lower: true });
  if (integrationName.length < 6 || typeSlug.length < 6) {
    throw new Error("Integration name cannot be shorter than 6 characters.");
  }
  let targetDir = explicitOutputPath != null ? explicitOutputPath : process.cwd();
  if (!(0, import_fs3.existsSync)(targetDir)) {
    (0, import_fs3.mkdirSync)(targetDir, { recursive: true });
  }
  if ((0, import_fs3.readdirSync)(targetDir).length > 0) {
    targetDir = import_path3.default.resolve(targetDir, typeSlug);
    if ((0, import_fs3.existsSync)(targetDir)) {
      throw new Error(`${targetDir} directory already exists, choose a different name.`);
    }
  }
  return { targetDir, typeSlug };
}

// src/spinner.ts
var makeSpinner = () => {
  const spinners = [];
  const stopAllSpinners = () => spinners.forEach((spinner) => spinner.stop());
  const spin = async (text) => {
    const spinner = await import("ora").then((ora) => ora.default(text).start());
    spinners.push(spinner);
    const minWait = new Promise((resolve) => setTimeout(resolve, 500));
    return async () => {
      await minWait;
      spinner.stop();
    };
  };
  return { stopAllSpinners, spin };
};

// src/telemetry.ts
var import_crypto = __toESM(require("crypto"));
var import_posthog_node = require("posthog-node");

// package.json
var package_default = {
  name: "@uniformdev/uniform-new",
  version: "18.12.0",
  description: "Easily start new Uniform projects",
  license: "SEE LICENSE IN LICENSE.txt",
  files: [
    "./dist"
  ],
  sideEffects: false,
  main: "./dist/index.js",
  module: "./dist/index.esm.js",
  exports: {
    ".": {
      import: {
        types: "./dist/index.d.ts",
        node: "./dist/index.mjs",
        default: "./dist/index.esm.js"
      },
      require: {
        types: "./dist/index.d.ts",
        default: "./dist/index.js"
      }
    }
  },
  types: "./dist/index.d.ts",
  typesVersions: {
    "*": {
      ".": [
        "./dist/index.d.ts"
      ]
    }
  },
  scripts: {
    clean: "rimraf dist",
    lint: 'eslint "src/*.ts"',
    format: 'prettier --write "src/*.ts"',
    build: "tsup",
    dev: "tsup --watch"
  },
  devDependencies: {
    "@types/degit": "2.8.3",
    "@types/inquirer": "9.0.3",
    "@types/jsonwebtoken": "9.0.1",
    "@types/node": "18.11.17",
    "@types/yargs": "17.0.22"
  },
  dependencies: {
    degit: "2.8.4",
    execa: "5.1.1",
    graphql: "16.6.0",
    "graphql-request": "5.1.0",
    inquirer: "8.2.5",
    jsonwebtoken: "9.0.0",
    open: "8.4.0",
    ora: "6.1.2",
    "posthog-node": "2.2.3",
    slugify: "1.6.5",
    yargs: "17.6.2",
    zod: "3.20.2"
  }
};

// src/telemetry.ts
var POSTHOG_WRITE_ONLY_KEY = "phc_c8YoKI9984KOHBfNrCRfIKvL56aYd5OpYxOdYexRzH7";
var Telemetry = class {
  constructor(prefix, disable = false) {
    this.prefix = prefix;
    this.distinctId = import_crypto.default.randomBytes(20).toString("hex");
    if (!disable) {
      this.posthog = new import_posthog_node.PostHog(POSTHOG_WRITE_ONLY_KEY, {
        flushAt: 1,
        flushInterval: 1
      });
      this.send("started");
    }
  }
  login(sub, user) {
    if (!this.posthog) {
      return;
    }
    const alias = this.distinctId;
    this.distinctId = sub;
    this.posthog.alias({ distinctId: this.distinctId, alias });
    this.posthog.identify({
      distinctId: this.distinctId,
      properties: {
        email: user.email_address,
        sub,
        teamCount: user.teams.length
      }
    });
    this.send("logged in");
  }
  send(event, properties = {}) {
    var _a;
    (_a = this.posthog) == null ? void 0 : _a.capture({
      distinctId: this.distinctId,
      event: [this.prefix, event].join(" "),
      properties: {
        version: package_default.version,
        ...properties
      }
    });
  }
  shutdown() {
    var _a;
    this.send("exited", { exitCode: process.exitCode });
    return (_a = this.posthog) == null ? void 0 : _a.shutdownAsync();
  }
};

// src/index.ts
var stableApiHost = "https://uniform.app";
var apiHostDefault = process.env.UNIFORM_CLI_BASE_URL || stableApiHost;
var disableTelemetryDefault = !["", "0", "false", "no"].includes(
  process.env.UNIFORM_CLI_DISABLE_TELEMETRY || ""
);
var newCmd = {
  command: "new [name]",
  builder: (y) => y.positional("name", {
    describe: "Name of a project",
    type: "string"
  }).option("apiHost", {
    describe: `Uniform host. Defaults to UNIFORM_CLI_BASE_URL env or ${stableApiHost}. Supports dotenv.`,
    default: apiHostDefault,
    demandOption: true,
    type: "string"
  }).option("outputPath", {
    alias: "o",
    description: "Specify where to store integration files. Defaults to cwd.",
    type: "string"
  }).option("disableTelemetry", {
    describe: "By default, usage information is sent to Uniform. Use this option or set UNIFORM_CLI_DISABLE_TELEMETRY to disable telemetry.",
    default: disableTelemetryDefault,
    demandOption: true,
    type: "boolean"
  }),
  describe: "Start a new Uniform project",
  handler: async function({ name, apiHost, outputPath, disableTelemetry }) {
    const { stopAllSpinners, spin } = makeSpinner();
    const telemetry = new Telemetry("cli new", disableTelemetry || apiHost !== stableApiHost);
    try {
      await newHandler({ spin, projectName: name, apiHost, outputPath, telemetry });
      stopAllSpinners();
      process.exit(0);
    } catch (err) {
      stopAllSpinners();
      telemetry.send("flow errored", { message: err.message });
      console.error(err.message);
      process.exitCode = 1;
    } finally {
      await telemetry.shutdown();
    }
  }
};
var newMeshCmd = {
  command: "new-integration",
  builder: (y) => y.option("apiHost", {
    describe: `Uniform host. Defaults to UNIFORM_CLI_BASE_URL env or ${stableApiHost}. Supports dotenv.`,
    default: apiHostDefault,
    demandOption: true,
    type: "string"
  }).option("outputPath", {
    alias: "o",
    description: "Specify where to store integration files. Defaults to cwd.",
    type: "string"
  }).option("disableTelemetry", {
    describe: "By default, usage information is sent to Uniform. Use this option or set UNIFORM_CLI_DISABLE_TELEMETRY to disable telemetry.",
    default: disableTelemetryDefault,
    demandOption: true,
    type: "boolean"
  }),
  describe: "Start a new Uniform project",
  handler: async function({ apiHost, outputPath, disableTelemetry }) {
    const { stopAllSpinners, spin } = makeSpinner();
    const telemetry = new Telemetry("cli new mesh", disableTelemetry || apiHost !== stableApiHost);
    try {
      await newMeshIntegrationHandler({ spin, apiHost, outputPath, telemetry });
      stopAllSpinners();
      process.exit(0);
    } catch (err) {
      stopAllSpinners();
      telemetry.send("flow errored", { message: err.message });
      console.error(err.message);
      process.exitCode = 1;
    } finally {
      await telemetry.shutdown();
    }
  }
};
var uniformCLI = { commands: [newCmd, newMeshCmd] };
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  uniformCLI
});
