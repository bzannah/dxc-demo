import { ApiClient, ClientOptions, ExceptProject, ApiClientError } from '@uniformdev/context/api';
export { ApiClientError } from '@uniformdev/context/api';
import { C as CompositionGetParameters, a as CompositionGetByNodePathParameters, D as DataResolutionOptionNegative, b as CompositionGetResponse, c as DataResolutionOptionPositive, d as DataResolutionParameters, e as CompositionResolvedGetResponse, f as CompositionGetValidResponses, g as DataResolutionOption, h as CompositionGetByNodeIdParameters, i as CompositionGetBySlugParameters, j as CompositionGetByIdParameters, k as CompositionPutParameters, l as CompositionDeleteParameters, m as ComponentDefinitionGetParameters, n as ComponentDefinitionPutParameters, o as ComponentDefinitionDeleteParameters, p as ComponentInstance, q as ComponentParameter, r as components, s as DataSourceGetParameters, t as DataSourcesGetParameters, u as DataSourcePutParameters, v as DataSourceDeleteParameters, w as DataTypeGetParameters, x as DataTypeGetResponse, y as DataTypePutParameters, z as DataTypeDeleteParameters, P as PreviewEventBus, U as UpdateCompositionMessage, R as RootComponentInstance } from './createEventBus-60ff8dc4.js';
export { B as AddComponentMessage, ah as CanvasDefinitions, O as Channel, F as ChannelMessage, T as ChannelSubscription, a4 as ComponentDefinition, Z as ComponentDefinitionAPIDeleteRequest, Y as ComponentDefinitionAPIPutRequest, X as ComponentDefinitionAPIResponse, W as ComponentDefinitionGetResponse, _ as ComponentDefinitionListAPIOptions, $ as ComponentDefinitionParameter, a3 as ComponentDefinitionPermission, a2 as ComponentDefinitionSlot, a1 as ComponentDefinitionSlugSettings, a0 as ComponentDefinitionVariant, aa as CompositionAPIDeleteRequest, ac as CompositionAPIOptions, a9 as CompositionAPIResponse, ao as CompositionDataDiagnostic, a8 as CompositionGetListResponse, a6 as CompositionGetOrderBy, ai as CompositionIssue, ab as CompositionListAPIResponse, aj as CompositionPatternIssue, a7 as CompositionUIStatus, a5 as CreatingComponentDefinition, ak as DataElementBindingIssue, ad as DataElementConnectionDefinition, an as DataResolutionConfigIssue, ag as DataResourceDefinition, af as DataResourceDefinitions, al as DataResourceIssue, am as DataResourceVariableIssue, ae as DataResourceVariables, as as DataSource, ap as DataSourceGetResponse, aq as DataSourcesGetResponse, ar as DataType, at as DataVariableDefinition, E as DismissPlaceholderMessage, N as MessageHandler, M as MoveComponentMessage, A as ReadyMessage, S as SelectComponentMessage, Q as createCanvasChannel, V as createEventBus, J as isAddComponentMessage, L as isDismissPlaceholderMessage, K as isMovingComponentMessage, H as isReadyMessage, G as isSelectComponentMessage, I as isUpdateCompositionMessage } from './createEventBus-60ff8dc4.js';
import { Options as Options$1 } from 'p-retry';
import { Options } from 'p-throttle';
import { PersonalizedVariant, TestVariant } from '@uniformdev/context';
import 'pusher-js';

type CanvasClientOptions = ClientOptions & {
    edgeApiHost?: string;
};
declare class CanvasClient extends ApiClient<CanvasClientOptions> {
    private edgeApiHost;
    constructor(options: CanvasClientOptions);
    /** Fetches lists of Canvas compositions, optionally by type */
    getCompositionList(options?: Omit<CompositionGetParameters, 'projectId' | 'compositionId' | 'slug'>): Promise<{
        compositions: {
            state: number;
            uiStatus?: "Draft" | "Modified" | "Published" | "Orphan" | undefined;
            projectId: string;
            created: string;
            modified: string;
            pattern: boolean;
            composition: {
                type: string;
                parameters?: {
                    [key: string]: {
                        value: unknown;
                        type: string;
                        connectedData?: {
                            pointer: string;
                            syntax: "jptr";
                            required?: boolean | undefined;
                        } | undefined;
                    };
                } | undefined;
                variant?: string | undefined;
                projectMapNodes?: {
                    id: string;
                    path: string;
                    projectMapId: string;
                }[] | undefined;
                slots?: {
                    [key: string]: {
                        type: string;
                        parameters?: {
                            [key: string]: {
                                value: unknown;
                                type: string;
                                connectedData?: {
                                    pointer: string;
                                    syntax: "jptr";
                                    required?: boolean | undefined;
                                } | undefined;
                            };
                        } | undefined;
                        variant?: string | undefined;
                        slots?: {
                            [key: string]: any[];
                        } | undefined;
                        _id?: string | undefined;
                        _pattern?: string | undefined;
                        _dataResources?: {
                            [key: string]: {
                                type: string;
                                isPatternParameter?: boolean | undefined;
                                variables?: {
                                    [key: string]: string;
                                } | undefined;
                            };
                        } | undefined;
                        _patternDataResources?: {
                            [key: string]: {
                                type: string;
                                isPatternParameter?: boolean | undefined;
                                variables?: {
                                    [key: string]: string;
                                } | undefined;
                            };
                        } | undefined;
                        _patternError?: "NOTFOUND" | "CYCLIC" | undefined;
                    }[];
                } | undefined;
                _id: string;
                _slug?: string | null | undefined;
                _name: string;
                _dataResources?: {
                    [key: string]: {
                        type: string;
                        isPatternParameter?: boolean | undefined;
                        variables?: {
                            [key: string]: string;
                        } | undefined;
                    };
                } | undefined;
            };
        }[];
        totalCount?: number | undefined;
    }>;
    /** Fetches one composition by its project map node path */
    unstable_getCompositionByNodePath(options: CompositionGetByNodePathParameters & DataResolutionOptionNegative): Promise<CompositionGetResponse>;
    unstable_getCompositionByNodePath(options: CompositionGetByNodePathParameters & DataResolutionOptionPositive & DataResolutionParameters): Promise<CompositionResolvedGetResponse>;
    unstable_getCompositionByNodePath<T extends CompositionGetResponse = CompositionGetValidResponses>(options: CompositionGetByNodePathParameters & DataResolutionOption & DataResolutionParameters): Promise<T>;
    /** Fetches one composition by its project map node ID */
    unstable_getCompositionByNodeId(options: CompositionGetByNodeIdParameters & DataResolutionOptionNegative): Promise<CompositionGetResponse>;
    unstable_getCompositionByNodeId(options: CompositionGetByNodeIdParameters & DataResolutionOptionPositive & DataResolutionParameters): Promise<CompositionResolvedGetResponse>;
    unstable_getCompositionByNodeId<T extends CompositionGetResponse = CompositionGetValidResponses>(options: CompositionGetByNodeIdParameters & DataResolutionOption & DataResolutionParameters): Promise<T>;
    /** Fetches one composition by its slug */
    getCompositionBySlug(options: CompositionGetBySlugParameters & DataResolutionOptionNegative): Promise<CompositionGetResponse>;
    getCompositionBySlug(options: CompositionGetBySlugParameters & DataResolutionOptionPositive & DataResolutionParameters): Promise<CompositionResolvedGetResponse>;
    getCompositionBySlug<T extends CompositionGetResponse = CompositionGetValidResponses>(options: CompositionGetBySlugParameters & DataResolutionOption & DataResolutionParameters): Promise<T>;
    /** Fetches one composition by its ID */
    getCompositionById(options: CompositionGetByIdParameters & DataResolutionOptionNegative): Promise<CompositionGetResponse>;
    getCompositionById(options: CompositionGetByIdParameters & DataResolutionOptionPositive & DataResolutionParameters): Promise<CompositionResolvedGetResponse>;
    getCompositionById<T extends CompositionGetResponse = CompositionGetValidResponses>(options: CompositionGetByIdParameters & DataResolutionOption & DataResolutionParameters): Promise<T>;
    private getOneComposition;
    /** Updates or creates a Canvas component definition */
    updateComposition(body: Omit<CompositionPutParameters, 'projectId'>): Promise<void>;
    /** Deletes a Canvas component definition */
    removeComposition(body: Omit<CompositionDeleteParameters, 'projectId'>): Promise<void>;
    /** Fetches all Canvas component definitions */
    getComponentDefinitions(options?: Omit<ComponentDefinitionGetParameters, 'projectId'>): Promise<{
        componentDefinitions: {
            id: string;
            name: string;
            icon?: string | undefined;
            titleParameter?: string | null | undefined;
            canBeComposition?: boolean | undefined;
            parameters?: {
                id: string;
                name: string;
                helpText?: string | undefined;
                type: string;
                typeConfig?: unknown;
            }[] | undefined;
            useTeamPermissions?: boolean | undefined;
            permissions?: {
                roleId: string;
                permission: "read" | "write" | "create" | "delete";
                state: number;
            }[] | undefined;
            slots?: {
                id: string;
                name: string;
                allowedComponents: string[];
                inheritAllowedComponents: boolean;
                minComponents?: number | undefined;
                maxComponents?: number | undefined;
            }[] | undefined;
            slugSettings?: {
                required?: "no" | "yes" | "disabled" | undefined;
                unique?: "no" | "local" | "global" | undefined;
                regularExpression?: string | undefined;
                regularExpressionMessage?: string | undefined;
            } | undefined;
            defaults?: {
                type: string;
                parameters?: {
                    [key: string]: {
                        value: unknown;
                        type: string;
                        connectedData?: {
                            pointer: string;
                            syntax: "jptr";
                            required?: boolean | undefined;
                        } | undefined;
                    };
                } | undefined;
                variant?: string | undefined;
                slots?: {
                    [key: string]: any[];
                } | undefined;
                _id?: string | undefined;
                _pattern?: string | undefined;
                _dataResources?: {
                    [key: string]: {
                        type: string;
                        isPatternParameter?: boolean | undefined;
                        variables?: {
                            [key: string]: string;
                        } | undefined;
                    };
                } | undefined;
                _patternDataResources?: {
                    [key: string]: {
                        type: string;
                        isPatternParameter?: boolean | undefined;
                        variables?: {
                            [key: string]: string;
                        } | undefined;
                    };
                } | undefined;
                _patternError?: "NOTFOUND" | "CYCLIC" | undefined;
            } | null | undefined;
            variants?: {
                id: string;
                name: string;
            }[] | undefined;
            created?: string | undefined;
            updated?: string | undefined;
        }[];
    }>;
    /** Updates or creates a Canvas component definition */
    updateComponentDefinition(body: Omit<ComponentDefinitionPutParameters, 'projectId'>): Promise<void>;
    /** Deletes a Canvas component definition */
    removeComponentDefinition(body: Omit<ComponentDefinitionDeleteParameters, 'projectId'>): Promise<void>;
}
declare class UncachedCanvasClient extends CanvasClient {
    constructor(options: Omit<CanvasClientOptions, 'bypassCache'>);
}

type EnhancerContext = {
    preview?: boolean;
};
/** Options passed to a ComponentEnhancer function */
type ComponentEnhancerOptions<TContext extends EnhancerContext = EnhancerContext> = {
    component: Readonly<ComponentInstance>;
    context: TContext;
};
/**
 * A function which is called for each matching component in a composition, which can manipulate the value of a specific key in the component's `data` property.
 * Used to enhance layout data with information from other platforms, such as private APIs, where the value is not tied to a parameter
 * and is intrinsic to the component itself.
 *
 * Note: the configuration of enhancers namespaces component enhancers into a named property on the data object to avoid collisions,
 * thus an enhancer need not worry about merging values with other enhancers, nor which key it has been registered under.
 *
 * Return values:
 * TValue - sets the configured key in the component's data value to this value
 * undefined - do not set the component's data key
 */
type ComponentEnhancerFunction<TValue = unknown, TContext extends EnhancerContext = EnhancerContext> = (options: ComponentEnhancerOptions<TContext>) => Promise<TValue | undefined> | TValue | undefined;
/**
 * Defines logic to add arbitrary async data to a component's `data` property.
 * Used to enhance layout data with information from other platforms, such as private APIs,
 * where the value is not tied to a parameter and is intrinsic to the component itself.
 */
type ComponentEnhancer<TValue = unknown, TContext extends EnhancerContext = EnhancerContext> = {
    /** Function called to enhance a single component in a composition. */
    enhanceOne: ComponentEnhancerFunction<TValue, TContext>;
    /**
     * The limit policy that defines how much concurrency and retry is allowed for this enhancer.
     * If the enhancer does not define completeAll(), this limit policy is applied to enhanceOne() calls.
     * If the enhancer does define completeAll(), this limit policy is applied to the completeAll() calls.
     * If the limit policy is undefined, unbounded concurrency is allowed and no error retrying will occur.
     */
    limitPolicy?: LimitPolicy;
    completeAll?: () => Promise<void>;
};
/** Options passed to a ComponentParameterEnhancer function */
type ComponentParameterEnhancerOptions<TRawValue = unknown, TContext extends EnhancerContext = EnhancerContext> = {
    parameter: Readonly<ComponentParameter<TRawValue>>;
    parameterName: string;
    component: Readonly<ComponentInstance>;
    context: TContext;
};
/**
 * A function which is called for each component parameter in a component tree, which can manipulate the value of the parameter.
 * Used to enhance layout data with information from other platforms, such as CMS, commerce, indexing, etc.
 *
 * Return values:
 * TValue - replaces the original parameter value with this value
 * undefined - do not change the original parameter value
 * null - sets the parameter value to null, replacing any existing value (i.e. if its value could not be resolved in an external system)
 */
type ComponentParameterEnhancerFunction<TRawValue = unknown, TOutputValue = unknown, TContext extends EnhancerContext = EnhancerContext> = (options: ComponentParameterEnhancerOptions<TRawValue, TContext>) => Promise<TOutputValue | undefined | null> | TOutputValue | undefined | null;
/**
 * Defines logic to replace the value of a component parameter with arbitrary async data.
 * Used to enhance layout data with information from other platforms, such as CMS, commerce, indexing, etc,
 * where that data is directly expandable from a parameter value.
 */
type ComponentParameterEnhancer<TRawValue = unknown, TOutputValue = unknown, TContext extends EnhancerContext = EnhancerContext> = {
    /** Function called to enhance a single parameter to be enhanced. */
    enhanceOne: ComponentParameterEnhancerFunction<TRawValue, TOutputValue, TContext>;
    /**
     * The limit policy that defines how much concurrency and retry is allowed for this enhancer.
     * If the enhancer does not define completeAll(), this limit policy is applied to enhanceOne() calls.
     * If the enhancer does define completeAll(), this limit policy is applied to the completeAll() calls.
     * If the limit policy is undefined, unbounded concurrency is allowed and no error retrying will occur.
     */
    limitPolicy?: LimitPolicy;
    /**
     * Function called, if defined, after all enhanceOne() calls have completed for the composition being enhanced.
     * Used to enable batching.
     * Return the number of batched items processed (or zero if that does not apply).
     */
    completeAll?: () => Promise<number>;
};

type schemas = components['schemas'];
type InvalidationPayload = schemas['InvalidationPayload'];
type InvalidationResult = schemas['InvalidationResult'];
type InvalidationInput = InvalidationResult['input'];

/**
 * @deprecated
 */
declare class DataSourceClient extends ApiClient {
    constructor(options: ClientOptions);
    /** Fetches all DataSources for a project */
    get(options?: ExceptProject<DataSourceGetParameters>): Promise<{
        result: {
            id: string;
            displayName: string;
            connectorType: string;
            baseUrl: string;
            headers?: {
                key: string;
                value: string;
            }[] | undefined;
            parameters?: {
                key: string;
                value: string;
            }[] | undefined;
            variables?: {
                [key: string]: {
                    displayName?: string | undefined;
                    helpText?: string | undefined;
                    type?: string | undefined;
                    default: string;
                    order?: number | undefined;
                };
            } | undefined;
            custom?: {
                [key: string]: unknown;
            } | undefined;
        };
    }>;
    /** Fetches all DataSources for a project */
    getList(options?: ExceptProject<DataSourcesGetParameters>): Promise<{
        results: {
            id: string;
            displayName: string;
            connectorType: string;
            baseUrl: string;
            headers?: {
                key: string;
                value: string;
            }[] | undefined;
            parameters?: {
                key: string;
                value: string;
            }[] | undefined;
            variables?: {
                [key: string]: {
                    displayName?: string | undefined;
                    helpText?: string | undefined;
                    type?: string | undefined;
                    default: string;
                    order?: number | undefined;
                };
            } | undefined;
            custom?: {
                [key: string]: unknown;
            } | undefined;
        }[];
    }>;
    /** Updates or creates (based on id) a DataSource */
    upsert(body: ExceptProject<DataSourcePutParameters>): Promise<void>;
    /** Deletes a DataSource */
    remove(body: ExceptProject<DataSourceDeleteParameters>): Promise<void>;
}

/**
 * @deprecated
 */
declare class DataTypeClient extends ApiClient {
    #private;
    constructor(options: ClientOptions);
    /** Fetches all DataTypes for a project */
    get(options?: ExceptProject<DataTypeGetParameters>): Promise<DataTypeGetResponse>;
    /** Updates or creates (based on id) a DataType */
    upsert(body: ExceptProject<DataTypePutParameters>): Promise<void>;
    /** Deletes a DataType */
    remove(body: ExceptProject<DataTypeDeleteParameters>): Promise<void>;
}

/** A single entry in a batch of queued enhancements. */
declare class BatchEntry<TArgs, TResult> {
    private _resolve;
    private _reject;
    args: TArgs;
    private _isCompleted;
    constructor(_resolve: (result: TResult) => void, _reject: (reason: any) => void, args: TArgs);
    /** Mark the batch entry as successfully completed. */
    resolve(result: TResult): void;
    /** Mark the batch entry as failed. */
    reject(reason: any): void;
    /** @return Whether the batch entry has been completed (resolved or rejected). */
    get isCompleted(): boolean;
}
/**
 * An enhancer that queues up promises for each component that needs enhancing,
 * and once all enhancements have been queued handles them all in a batch.
 * Note: this type is adaptable to both ComponentParameterEnhancer and ComponentEnhancer types.
 */
type BatchEnhancer<TArgs, TResult> = {
    /** Adds a promise to the enhancement queue. */
    enhanceOne: (args: TArgs) => Promise<TResult | undefined>;
    /** Calls the batch enhancer function for all queued promises and resolves them. Returns number of processed items. */
    completeAll: () => Promise<number>;
    limitPolicy?: LimitPolicy;
};
/**
 * Creates an enhancer that batches up all enhancements for a composition into a set of promises,
 * and then handles them all in a single batch. Used to reduce the number of HTTP requests
 * needed to fulfill layout enhancements when a layout uses many resources from other systems.
 */
declare function createBatchEnhancer<TArgs, TResult>({ handleBatch, shouldQueue, limitPolicy, }: {
    /** Function called to handle one or more batched up enhancements. (note: queue will never be an empty array) */
    handleBatch: (queue: ReadonlyArray<Readonly<BatchEntry<TArgs, TResult>>>) => Promise<void>;
    /** Function called to determine if a given enhancement should be queued, i.e. don't queue invalid or null/undefined values. */
    shouldQueue?: (args: TArgs) => boolean;
    limitPolicy?: LimitPolicy;
}): BatchEnhancer<TArgs, TResult>;

/**
 * Composes several enhancers into a synchronous chain. Can be used to modify the output of an enhancer.
 * NOTE: only the first enhancer in the chain may use batching (completeAll()).
 */
declare const compose: (input: ComponentParameterEnhancer<any, any> | ComponentParameterEnhancerFunction<any>, ...composers: ReadonlyArray<ComponentParameterEnhancer<any, any> | ComponentParameterEnhancerFunction<any>>) => ComponentParameterEnhancer<any, any>;

type LimitPolicy = <ReturnValue>(func: () => Promise<ReturnValue>) => Promise<ReturnValue>;
declare function createLimitPolicy({ throttle, retry, }: {
    throttle?: Options | false;
    retry?: Options$1 | false;
}): LimitPolicy;
declare const nullLimitPolicy: LimitPolicy;

/**
 * Builds a definition of the enhancers to run on Canvas components to add data from other systems.
 * Note that only the first matching enhancer will be run.
 */
declare class ChildEnhancerBuilder {
    private _paramMatches;
    private _dataMatches;
    /** Targets an enhancer to modify the value of any parameter */
    parameter(enhancer: ComponentParameterEnhancer<any, any> | ComponentParameterEnhancerFunction<any>): this;
    /** Targets an enhancer to modify the value of any parameter with a specific name */
    parameterName(name: string | readonly string[], enhancer: ComponentParameterEnhancer<any, any> | ComponentParameterEnhancerFunction<any>): this;
    /** Targets an enhancer to modify the value of any parameter with a specific type */
    parameterType(type: string | readonly string[], enhancer: ComponentParameterEnhancer<any, any> | ComponentParameterEnhancerFunction<any>): this;
    /**
     * Targets an enhancer to set a specific object key on the component's `data` property.
     * Note: an exception will be thrown if the same key is registered more than once.
     */
    data(name: string, enhancer: ComponentEnhancer<any> | ComponentEnhancerFunction<any>): this;
    /**
     * Resolves the parameter enhancer for a given parameter, if one exists.
     * The first matching enhancer by registration order is returned, if more than one could match.
     */
    resolveParameterEnhancer(parameterName: string, parameter: ComponentParameter): ComponentParameterEnhancer<unknown, unknown, EnhancerContext> | undefined;
    /**
     * Resolves component enhancer(s) for a given component.
     * Returns a Map where the key is the name of the data property and the value is the enhancer.
     */
    resolveComponentEnhancers(): Map<string, ComponentEnhancer<unknown, EnhancerContext>>;
    private _resolveParameterEnhancer;
}
/**
 * Builds a definition of the enhancers to run on Canvas components to add data from other systems.
 * Note that only the first matching enhancer will be run.
 */
declare class EnhancerBuilder {
    private _componentIndex;
    private _rootBuilder;
    /** Targets an enhancer to modify the value of any parameter */
    parameter(enhancer: ComponentParameterEnhancer<any, any> | ComponentParameterEnhancerFunction): this;
    /** Targets an enhancer to modify the value of any parameter with a specific name */
    parameterName(name: string | readonly string[], enhancer: ComponentParameterEnhancer<any, any> | ComponentParameterEnhancerFunction): this;
    /** Targets an enhancer to modify the value of any parameter with a specific type */
    parameterType(type: string | readonly string[], enhancer: ComponentParameterEnhancer<any, any> | ComponentParameterEnhancerFunction<any>): this;
    /**
     * Targets an enhancer to set a specific object key on the component's `data` property.
     * Note: an exception will be thrown if the same key is registered more than once.
     */
    data(name: string, enhancer: ComponentEnhancer<any> | ComponentEnhancerFunction<any>): this;
    /**
     * Targets a subset of enhancers at a specific component type.
     * Global enhancers will still be run if no matching enhancer is registered for this component's properties.
     */
    component(name: string | readonly string[], builder: (builder: ChildEnhancerBuilder) => void): EnhancerBuilder;
    /**
     * Resolves the parameter enhancer for a given parameter, if one exists.
     * The first matching enhancer by registration order is returned, if more than one could match.
     */
    resolveParameterEnhancer(component: ComponentInstance, parameterName: string, parameter: ComponentParameter): ComponentParameterEnhancer<unknown, unknown, EnhancerContext> | undefined;
    /**
     * Resolves component enhancer(s) for a given component.
     * Returns a Map where the key is the name of the data property and the value is the enhancer.
     */
    resolveComponentEnhancers(component: ComponentInstance): Map<string, ComponentEnhancer<unknown, EnhancerContext>>;
}

type EnhancerError = {
    message: string;
    error: Error | string;
};
/**
 * Applies enhancer functions to a component tree.
 * IMPORTANT: the input composition object is mutated. Plan accordingly.
 * Want immutability? Grab immer :)
 */
declare function enhance<TContext extends EnhancerContext = EnhancerContext>({ composition, enhancers, context, onErrors, }: {
    composition: ComponentInstance;
    enhancers: EnhancerBuilder;
    context: TContext;
    onErrors?: (errors: EnhancerError[]) => void;
}): Promise<void>;

declare function extractLocales({ component }: {
    component: ComponentInstance;
}): Record<string, ComponentInstance[]>;
declare function localize({ composition, locale, }: {
    composition: ComponentInstance;
    locale: string | ((options: {
        component: Readonly<ComponentInstance>;
        locales: Readonly<Record<string, ComponentInstance[]>>;
    }) => string | undefined);
}): void;

/**
 * Given a batch of enhancements containing potentially duplicate entries (i.e. several components referencing the same thing),
 * group them together by some unique identifier and enable simpler batch processing.
 */
declare class UniqueBatchEntries<TArgs, TResult> {
    groups: Readonly<Record<string, ReadonlyArray<Readonly<BatchEntry<TArgs, TResult>>>>>;
    constructor(
    /** The batch queue being processed. */
    entries: ReadonlyArray<Readonly<BatchEntry<TArgs, TResult>>>, 
    /** A function to select the unique identifier for a given batch entry. */
    uniqueKeySelector: (entry: Readonly<TArgs>) => string);
    /** Resolves all entries in a group key with the same result value. */
    resolveKey(key: string, result: TResult): void;
    /** Resolves all remaining entries that have not been otherwise resolved with a specific value */
    resolveRemaining(value: TResult): void;
}

type ComponentLocationReference = {
    component: ComponentInstance;
    parentSlot?: string;
    parentSlotIndex?: number;
};
type WalkComponentTreeActions<TContext> = {
    /** Replaces the component being visited with a new object */
    replaceComponent: (replacementComponent: ComponentInstance) => void;
    /** Removes the component being visited from the composition */
    removeComponent: () => void;
    /** Inserts a new component immediately after the current component in its parent slot */
    insertAfter: (components: ComponentInstance | ComponentInstance[]) => void;
    /** Aborts visitation of components that are in child slots of the current component */
    stopProcessingDescendants: () => void;
    /**
     * Set a new traversal context for descendants of this node.
     * If this is not called, `context` will automatically pass through.
     */
    setDescendantsContext: (context: TContext) => void;
    setChildContext: (child: ComponentInstance, context: TContext) => void;
};
/** Walks a composition's component tree, visiting each component instance depth-first, in order. */
declare function walkComponentTree<TContext = unknown>(component: ComponentInstance, visitor: (component: ComponentInstance, ancestorsAndSelf: Array<ComponentLocationReference>, actions: WalkComponentTreeActions<TContext>, 
/** Traversal context for this node */
currentContext: TContext | undefined) => void, initialContext?: TContext): void;
declare function getComponentPath(ancestorsAndSelf: Array<ComponentLocationReference>): string;
/** Returns the JSON pointer of a component based on its location */
declare function getComponentJsonPointer(ancestorsAndSelf: Array<ComponentLocationReference>, { withSlots }?: {
    withSlots?: boolean | undefined;
}): string;

type EventNames = 'updated';

declare function getChannelName(projectId: string, compositionId: string, state: number): string;

type SubscribeToCompositionOptions = {
    projectId: string;
    compositionId: string;
    compositionState: number;
    callback: (data: unknown) => void;
    eventBus: PreviewEventBus;
    event: EventNames;
};
type UnsubscribeCallback = () => void;
/** Subscribes to a composition event */
declare function subscribeToComposition({ projectId, compositionId, compositionState, eventBus: { subscribe }, callback, event, }: SubscribeToCompositionOptions): UnsubscribeCallback;

/** Public ID of Canvas personalization component type */
declare const CANVAS_PERSONALIZE_TYPE = "$personalization";
/** Public ID of Canvas A/B test component type */
declare const CANVAS_TEST_TYPE = "$test";
/** Public ID of Canvas localization component type */
declare const CANVAS_LOCALIZATION_TYPE = "$localization";
/** Public ID of the intent tag parameter on the Canvas personalization component type */
declare const CANVAS_INTENT_TAG_PARAM = "intentTag";
/** Public ID of the locale parameter on Canvas components */
declare const CANVAS_LOCALE_TAG_PARAM = "locale";
/** Name of the slot on CANVAS_PERSONALIZE_TYPE */
declare const CANVAS_PERSONALIZE_SLOT = "pz";
/** Name of the slot on CANVAS_TEST_TYPE */
declare const CANVAS_TEST_SLOT = "test";
/** Name of the slot on CANVAS_TEST_TYPE */
declare const CANVAS_LOCALIZATION_SLOT = "localized";
/** Constant for a draft composition state. Subject to change. */
declare const CANVAS_DRAFT_STATE = 0;
/** Constant for a published composition state. Subject to change. */
declare const CANVAS_PUBLISHED_STATE = 64;
/** Public ID of the Uniform Context personalization parameter on Canvas components */
declare const CANVAS_PERSONALIZATION_PARAM = "$pzCrit";
/** Public ID of the Uniform Context test variant parameter on Canvas components */
declare const CANVAS_TEST_VARIANT_PARAM = "$tstVrnt";
/** Public ID of the Uniform Context enrichment tag parameter on Canvas components */
declare const CANVAS_ENRICHMENT_TAG_PARAM = "$enr";
/** The name of the query string used to detect if we are in in-context editing mode */
declare const IN_CONTEXT_EDITOR_QUERY_STRING_PARAM = "is_incontext_editing_mode";
/** The value of "data-role" in the component start `<script>` tag */
declare const IN_CONTEXT_EDITOR_COMPONENT_START_ROLE = "uniform-component-start";
/** The ID of the Contextual Editing script that gets embedded in frontend apps */
declare const IN_CONTEXT_EDITOR_EMBED_SCRIPT_ID = "uniform-canvas-preview-script";
/** The ID we give to placeholder components */
declare const PLACEHOLDER_ID = "placeholder";
/** Minimal value for Edgehancers Cache TTL (in seconds) */
declare const EDGE_MIN_CACHE_TTL = 15;
/** Maximal value for Edgehancers Cache TTL (in seconds) */
declare const EDGE_MAX_CACHE_TTL = 600;
/** Default value for Edgehancers Cache TTL (in seconds) */
declare const EDGE_DEFAULT_CACHE_TTL = 30;
/** A value that indicates that Edgehancers caching is disabled */
declare const EDGE_CACHE_DISABLED = -1;
/** Minimal value for Edgehancers Long Term Cache TTL (in hours) */
declare const EDGE_MIN_L2_CACHE_TTL_IN_HOURS = 1;
/** Maximal value for Edgehancers Long Term Cache TTL (in hours) */
declare const EDGE_MAX_L2_CACHE_TTL_IN_HOURS: number;
/** Default value for Edgehancers Long Term Cache TTL (in hours) */
declare const EDGE_DEFAULT_L2_CACHE_TTL_IN_HOURS = 24;

/**
 * Creates an enhancer based on an API route.
 * This is mainly used to create an enhancer for Contextual Editing, which can be passed to the `contextualEditingEnhancer` prop of `<UniformComposition />`.
 *
 * @example
 * ```ts
 * const enhance = createUniformApiEnhancer({
 *   apiUrl: '/api/preview',
 * });
 * ```
 */
declare const createUniformApiEnhancer: ({ apiUrl }: {
    apiUrl: string;
}) => (message: UpdateCompositionMessage) => Promise<{
    type: string;
    parameters?: {
        [key: string]: {
            value: unknown;
            type: string;
            connectedData?: {
                pointer: string;
                syntax: "jptr";
                required?: boolean | undefined;
            } | undefined;
        };
    } | undefined;
    variant?: string | undefined;
    projectMapNodes?: {
        id: string;
        path: string;
        projectMapId: string;
    }[] | undefined;
    slots?: {
        [key: string]: {
            type: string;
            parameters?: {
                [key: string]: {
                    value: unknown;
                    type: string;
                    connectedData?: {
                        pointer: string;
                        syntax: "jptr";
                        required?: boolean | undefined;
                    } | undefined;
                };
            } | undefined;
            variant?: string | undefined;
            slots?: {
                [key: string]: any[];
            } | undefined;
            _id?: string | undefined;
            _pattern?: string | undefined;
            _dataResources?: {
                [key: string]: {
                    type: string;
                    isPatternParameter?: boolean | undefined;
                    variables?: {
                        [key: string]: string;
                    } | undefined;
                };
            } | undefined;
            _patternDataResources?: {
                [key: string]: {
                    type: string;
                    isPatternParameter?: boolean | undefined;
                    variables?: {
                        [key: string]: string;
                    } | undefined;
                };
            } | undefined;
            _patternError?: "NOTFOUND" | "CYCLIC" | undefined;
        }[];
    } | undefined;
    _id: string;
    _slug?: string | null | undefined;
    _name: string;
    _dataResources?: {
        [key: string]: {
            type: string;
            isPatternParameter?: boolean | undefined;
            variables?: {
                [key: string]: string;
            } | undefined;
        };
    } | undefined;
}>;

declare const generateHash: ({ composition, secret, }: {
    composition: RootComponentInstance;
    secret: string | undefined;
}) => number | undefined;

/** Determines if a given Canvas component type is a system-defined type */
declare const isSystemComponentDefinition: (componentType: string) => boolean;

/**
 * Converts components in a slot into personalized variations (based on each component's intent tag in Canvas) suitable to pass to a personalize component
 * Useful when implementing custom personalization settings for Canvas components.
 */
declare function mapSlotToPersonalizedVariations(slot: ComponentInstance[] | undefined): Array<ComponentInstance & PersonalizedVariant>;

/**
 * Converts components in a slot into test variations (based on each component's Context tag in Canvas) suitable to pass to a personalize component
 * Useful when implementing custom test settings for Canvas components.
 */
declare function mapSlotToTestVariations(slot: ComponentInstance[] | undefined): Array<ComponentInstance & TestVariant>;

declare const CanvasClientError: typeof ApiClientError;

export { BatchEnhancer, BatchEntry, CANVAS_DRAFT_STATE, CANVAS_ENRICHMENT_TAG_PARAM, CANVAS_INTENT_TAG_PARAM, CANVAS_LOCALE_TAG_PARAM, CANVAS_LOCALIZATION_SLOT, CANVAS_LOCALIZATION_TYPE, CANVAS_PERSONALIZATION_PARAM, CANVAS_PERSONALIZE_SLOT, CANVAS_PERSONALIZE_TYPE, CANVAS_PUBLISHED_STATE, CANVAS_TEST_SLOT, CANVAS_TEST_TYPE, CANVAS_TEST_VARIANT_PARAM, CanvasClient, CanvasClientError, ChildEnhancerBuilder, ComponentDefinitionDeleteParameters, ComponentDefinitionGetParameters, ComponentDefinitionPutParameters, ComponentEnhancer, ComponentEnhancerFunction, ComponentEnhancerOptions, ComponentInstance, ComponentLocationReference, ComponentParameter, ComponentParameterEnhancer, ComponentParameterEnhancerFunction, ComponentParameterEnhancerOptions, CompositionDeleteParameters, CompositionGetByIdParameters, CompositionGetByNodeIdParameters, CompositionGetByNodePathParameters, CompositionGetBySlugParameters, CompositionGetParameters, CompositionGetResponse, CompositionGetValidResponses, CompositionPutParameters, CompositionResolvedGetResponse, DataResolutionOption, DataResolutionOptionNegative, DataResolutionOptionPositive, DataResolutionParameters, DataSourceClient, DataSourceDeleteParameters, DataSourceGetParameters, DataSourcePutParameters, DataSourcesGetParameters, DataTypeClient, DataTypeDeleteParameters, DataTypeGetParameters, DataTypeGetResponse, DataTypePutParameters, EDGE_CACHE_DISABLED, EDGE_DEFAULT_CACHE_TTL, EDGE_DEFAULT_L2_CACHE_TTL_IN_HOURS, EDGE_MAX_CACHE_TTL, EDGE_MAX_L2_CACHE_TTL_IN_HOURS, EDGE_MIN_CACHE_TTL, EDGE_MIN_L2_CACHE_TTL_IN_HOURS, EnhancerBuilder, EnhancerContext, EnhancerError, EventNames, IN_CONTEXT_EDITOR_COMPONENT_START_ROLE, IN_CONTEXT_EDITOR_EMBED_SCRIPT_ID, IN_CONTEXT_EDITOR_QUERY_STRING_PARAM, InvalidationInput, InvalidationPayload, InvalidationResult, LimitPolicy, PLACEHOLDER_ID, PreviewEventBus, RootComponentInstance, SubscribeToCompositionOptions, UncachedCanvasClient, UniqueBatchEntries, UnsubscribeCallback, UpdateCompositionMessage, WalkComponentTreeActions, compose, createBatchEnhancer, createLimitPolicy, createUniformApiEnhancer, enhance, extractLocales, generateHash, getChannelName, getComponentJsonPointer, getComponentPath, isSystemComponentDefinition, localize, mapSlotToPersonalizedVariations, mapSlotToTestVariations, nullLimitPolicy, subscribeToComposition, walkComponentTree };
