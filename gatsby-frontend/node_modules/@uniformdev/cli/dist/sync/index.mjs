import {
  __toESM,
  require_source
} from "../chunk-IRPO3X2Q.mjs";

// src/sync/arraySyncEngineDataSource.ts
async function createArraySyncEngineDataSource({
  objects,
  selectIdentifier,
  selectDisplayName = selectIdentifier,
  onSyncComplete
}) {
  const objectIndex = objects.reduce((result, current) => {
    const identifier = selectIdentifier(current);
    if (result[identifier]) {
      throw new Error(`Identifier ${identifier} was not unique.`);
    }
    result[identifier] = {
      id: identifier,
      object: current,
      providerId: identifier,
      displayName: selectDisplayName(current)
    };
    return result;
  }, {});
  async function* getObjects() {
    for (const item of Object.values(objectIndex)) {
      yield item;
    }
  }
  function extractCurrent() {
    return Object.entries(objectIndex).sort((a, b) => a[0].localeCompare(b[0])).map((entry) => entry[1].object);
  }
  return {
    objects: getObjects(),
    deleteObject: async (providerId) => {
      delete objectIndex[providerId];
    },
    writeObject: async (objectToWrite) => {
      const id = selectIdentifier(objectToWrite.object);
      objectIndex[id] = objectToWrite;
    },
    extractCurrent,
    onSyncComplete: onSyncComplete ? (isTarget) => onSyncComplete(isTarget, extractCurrent()) : void 0
  };
}

// src/sync/fileSyncEngineDataSource.ts
var import_chalk = __toESM(require_source());
import { existsSync, mkdirSync } from "fs";
import { readdir, unlink } from "fs/promises";
import { extname as extname2, join } from "path";

// src/sync/util.ts
import { writeFileSync } from "fs";
import { readFileSync } from "fs";
import { HttpsProxyAgent } from "https-proxy-agent";
import unfetch from "isomorphic-unfetch";
import { dump, load } from "js-yaml";
import { extname } from "path";
function withApiOptions(yargs) {
  var _a, _b, _c;
  return yargs.option("apiKey", {
    describe: "Uniform API key. Defaults to UNIFORM_CLI_API_KEY or UNIFORM_API_KEY env. Supports dotenv.",
    default: (_c = (_b = (_a = process.env.UNIFORM_CLI_API_KEY) != null ? _a : process.env.CANVAS_CLI_API_KEY) != null ? _b : process.env.UPM_CLI_API_KEY) != null ? _c : process.env.UNIFORM_API_KEY,
    demandOption: true,
    type: "string"
  }).option("apiHost", {
    describe: "Uniform host. Defaults to UNIFORM_CLI_BASE_URL env var or https://uniform.app. Supports dotenv.",
    default: process.env.UNIFORM_CLI_BASE_URL || "https://uniform.app",
    demandOption: true,
    type: "string"
  }).option("edgeApiHost", {
    describe: "Uniform edge host. Defaults to UNIFORM_CLI_BASE_EDGE_URL env var or https://uniform.global. Supports dotenv.",
    default: process.env.UNIFORM_CLI_BASE_EDGE_URL || "https://uniform.global",
    demandOption: true,
    type: "string"
  }).option("proxy", {
    describe: "HTTPS proxy to use for Uniform API calls. Defaults to HTTPS_PROXY, https_proxy, ALL_PROXY, or all_proxy env vars (in that order). Supports dotenv.",
    default: process.env.HTTPS_PROXY || process.env.https_proxy || process.env.ALL_PROXY || process.env.all_proxy,
    type: "string"
  });
}
function nodeFetchProxy(proxy) {
  if (proxy) {
    console.log(`\u{1F991} Using proxy ${proxy}`);
  }
  const wrappedFetch = (input, init) => {
    if (proxy) {
      const wrappedInit = {
        ...init,
        agent: new HttpsProxyAgent(proxy)
      };
      return unfetch(input, wrappedInit);
    }
    return unfetch(input, init);
  };
  return wrappedFetch;
}
function withProjectOptions(yargs) {
  var _a, _b, _c;
  return yargs.option("project", {
    describe: "Uniform project ID. Defaults to UNIFORM_CLI_PROJECT_ID or UNIFORM_PROJECT_ID env. Supports dotenv.",
    default: (_c = (_b = (_a = process.env.UNIFORM_CLI_PROJECT_ID) != null ? _a : process.env.CANVAS_CLI_PROJECT_ID) != null ? _b : process.env.UPM_CLI_PROJECT_ID) != null ? _c : process.env.UNIFORM_PROJECT_ID,
    demandOption: true,
    type: "string",
    alias: ["p"]
  });
}
function withFormatOptions(yargs) {
  return yargs.option("format", {
    alias: ["f"],
    describe: "Output format",
    default: "yaml",
    choices: ["yaml", "json"],
    type: "string"
  }).option("filename", {
    alias: ["o"],
    describe: "Output filename. If not specified, write to stdout.",
    type: "string"
  });
}
function withDiffOptions(yargs) {
  var _a;
  return yargs.option("diff", {
    describe: "Whether to show diffs in stdout. off = no diffs; update = on for updates; on = updates, creates, deletes. Can be set by UNIFORM_CLI_DIFF_MODE environment variable.",
    default: (_a = process.env.UNIFORM_CLI_DIFF_MODE) != null ? _a : "off",
    type: "string",
    choices: ["off", "update", "on"],
    alias: ["d"]
  });
}
function isPathAPackageFile(path) {
  const extension = extname(path);
  return extension === ".yaml" || extension === ".yml" || extension === ".json";
}
function emitWithFormat(object, format, filename) {
  let content;
  if (filename && !format) {
    const extension = extname(filename);
    if (extension === ".yaml" || extension === ".yml") {
      format = "yaml";
    } else if (extension === ".json") {
      format = "json";
    }
  } else if (!format) {
    throw new Error("Format must be specified when no filename is passed");
  }
  switch (format) {
    case "json":
      content = JSON.stringify(object, null, 2);
      break;
    case "yaml":
      content = dump(object);
      break;
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
  if (filename) {
    writeFileSync(filename, content, "utf8");
  } else {
    console.log(content);
  }
}
function readFileToObject(filename) {
  const file = readFileSync(filename, "utf8");
  return load(file, { filename, json: true });
}
async function* paginateAsync(fetchPage, options) {
  const perPage = options.pageSize || 100;
  let offset = 0;
  let pageData = [];
  do {
    pageData = await fetchPage(offset, perPage);
    for (const item of pageData) {
      yield item;
    }
    offset += perPage;
  } while (pageData.length === perPage);
}

// src/sync/fileSyncEngineDataSource.ts
async function createFileSyncEngineDataSource({
  directory,
  format = "yaml",
  selectIdentifier,
  selectDisplayName = selectIdentifier,
  selectFilename
}) {
  const dirExists = existsSync(directory);
  if (!dirExists) {
    mkdirSync(directory, { recursive: true });
  }
  const rawFilenames = await readdir(directory, "utf-8");
  const filenames = new Set(
    rawFilenames.filter((filename) => {
      const ext = extname2(filename);
      return ext === `.json` || ext === `.yaml` || ext === `.yml`;
    })
  );
  const getFullFilename = (id) => join(directory, `${id}.${format}`);
  async function* getObjects() {
    for (const filename of filenames) {
      const fullFilename = join(directory, filename);
      try {
        const contents = await readFileToObject(fullFilename);
        const object = {
          id: selectIdentifier(contents),
          displayName: selectDisplayName(contents),
          providerId: fullFilename,
          object: contents
        };
        yield object;
      } catch (e) {
        console.error(import_chalk.default.red(`Failed to read ${fullFilename}, data is likely invalid.
${e == null ? void 0 : e.message}`));
        throw e;
      }
    }
  }
  return {
    objects: getObjects(),
    deleteObject: async (providerId) => {
      await unlink(providerId);
    },
    writeObject: async (object) => {
      if (selectFilename) {
        emitWithFormat(object.object, format, join(directory, `${selectFilename(object.object)}.${format}`));
      } else {
        emitWithFormat(object.object, format, getFullFilename(object.id));
      }
    }
  };
}

// src/sync/package.ts
import fs from "fs";
function readUniformPackage(filename, assertExists) {
  if (!assertExists && !fs.existsSync(filename)) {
    return {};
  }
  const packageContents = readFileToObject(filename);
  if (typeof packageContents !== "object") {
    throw new Error(`Package ${filename} does not appear valid.`);
  }
  return packageContents;
}
function writeUniformPackage(filename, packageContents) {
  emitWithFormat(packageContents, void 0, filename);
}

// src/sync/syncEngine.ts
import { diffJson, diffLines } from "diff";
import isEqualWith from "lodash.isequalwith";
async function syncEngine({
  source,
  target,
  compareContents = (source2, target2) => {
    return isEqualWith(
      source2.object,
      target2.object,
      (_a, _b, key) => key === "created" || key === "modified" ? true : void 0
    );
  },
  mode,
  allowEmptySource = false,
  whatIf = false,
  log = () => {
  }
}) {
  var _a, _b;
  const targetItems = /* @__PURE__ */ new Map();
  for await (const obj of target.objects) {
    targetItems.set(obj.id, obj);
  }
  const actions = [];
  let sourceHasItems = false;
  for await (const sourceObject of source.objects) {
    sourceHasItems = true;
    const id = sourceObject.id;
    const targetObject = targetItems.get(id);
    if (targetObject) {
      if (!compareContents(sourceObject, targetObject)) {
        if (mode === "createOrUpdate" || mode === "mirror") {
          const process2 = async (sourceObject2, targetObject2) => {
            var _a2;
            if (!whatIf) {
              try {
                await target.writeObject(sourceObject2, targetObject2);
              } catch (e) {
                throw new SyncEngineError(e, sourceObject2);
              }
            }
            log({
              action: "update",
              id,
              providerId: sourceObject2.providerId,
              displayName: (_a2 = sourceObject2.displayName) != null ? _a2 : sourceObject2.providerId,
              whatIf,
              diff: diffJson(targetObject2.object, sourceObject2.object)
            });
          };
          actions.push(process2(sourceObject, targetObject));
        }
      }
      targetItems.delete(id);
    } else {
      const process2 = async (sourceObject2, id2) => {
        var _a2;
        if (!whatIf) {
          try {
            await target.writeObject(sourceObject2);
          } catch (e) {
            throw new SyncEngineError(e, sourceObject2);
          }
        }
        log({
          action: "create",
          id: id2,
          providerId: id2,
          displayName: (_a2 = sourceObject2.displayName) != null ? _a2 : sourceObject2.providerId,
          whatIf,
          diff: diffLines("", JSON.stringify(sourceObject2.object, null, 2))
        });
      };
      actions.push(process2(sourceObject, id));
    }
  }
  await Promise.all(actions);
  if (mode === "mirror") {
    if (!sourceHasItems && !allowEmptySource) {
      throw new Error(
        "Source is empty and mode is mirror. This would cause deletion of everything in the target, and most likely indicates an error in source definition."
      );
    }
    const deletes = [];
    targetItems.forEach(async (object) => {
      const process2 = async (object2) => {
        var _a2;
        if (!whatIf) {
          try {
            await target.deleteObject(object2.providerId, object2);
          } catch (e) {
            throw new SyncEngineError(e, object2);
          }
        }
        log({
          action: "delete",
          id: object2.id,
          providerId: object2.providerId,
          displayName: (_a2 = object2.displayName) != null ? _a2 : object2.providerId,
          whatIf,
          diff: diffLines(JSON.stringify(object2.object, null, 2), "")
        });
      };
      deletes.push(process2(object));
    });
    await Promise.all(deletes);
  }
  await Promise.all([(_a = source.onSyncComplete) == null ? void 0 : _a.call(source, false), (_b = target.onSyncComplete) == null ? void 0 : _b.call(target, true)]);
}
var SyncEngineError = class extends Error {
  constructor(innerError, sourceObject) {
    var _a;
    super(
      `Error syncing ${(_a = sourceObject.displayName) != null ? _a : sourceObject.providerId} (${sourceObject.providerId})
${innerError}`
    );
    this.stack = void 0;
    Object.setPrototypeOf(this, SyncEngineError.prototype);
  }
};

// src/sync/syncEngineConsoleLogger.ts
var import_chalk2 = __toESM(require_source());
function createSyncEngineConsoleLogger(options) {
  const { diffMode = "off", indent, prefix } = options != null ? options : {};
  return function syncEngineConsoleLogger({ action, displayName, whatIf, diff }) {
    let actionTag = "";
    switch (action) {
      case "create":
        actionTag = import_chalk2.default.green("[A]");
        break;
      case "update":
        actionTag = import_chalk2.default.white("[U]");
        break;
      case "delete":
        actionTag = import_chalk2.default.yellow("[D]");
        break;
    }
    let diffString = "";
    if (diffMode === "on" || diffMode === "update" && action === "update") {
      diffString = "\n" + diff.map((change) => {
        if (change.added) {
          return import_chalk2.default.green(change.value);
        }
        if (change.removed) {
          return import_chalk2.default.red(change.value);
        }
        return change.value;
      }).join("");
    }
    console.log(
      `${indent != null ? indent : ""}${whatIf ? import_chalk2.default.gray("[WHATIF]") : ""}${actionTag}${prefix != null ? prefix : ""} ${displayName}${diffString}`
    );
  };
}
export {
  SyncEngineError,
  createArraySyncEngineDataSource,
  createFileSyncEngineDataSource,
  createSyncEngineConsoleLogger,
  emitWithFormat,
  isPathAPackageFile,
  nodeFetchProxy,
  paginateAsync,
  readFileToObject,
  readUniformPackage,
  syncEngine,
  withApiOptions,
  withDiffOptions,
  withFormatOptions,
  withProjectOptions,
  writeUniformPackage
};
